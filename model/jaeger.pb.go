// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: jaeger.proto

/*
	Package model is a generated protocol buffer package.

	It is generated from these files:
		jaeger.proto

	It has these top-level messages:
		TraceID
		KeyValue
		Log
		SpanRef
		Process
		Span
		Trace
		Batch
		GetTraceID
*/
package model

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/types"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/gogo/protobuf/gogoproto"

import time "time"

import bytes "bytes"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"
import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ValueType int32

const (
	ValueType_STRING ValueType = 0
	ValueType_DOUBLE ValueType = 1
	ValueType_BOOL   ValueType = 2
	ValueType_LONG   ValueType = 3
	ValueType_BINARY ValueType = 4
)

var ValueType_name = map[int32]string{
	0: "STRING",
	1: "DOUBLE",
	2: "BOOL",
	3: "LONG",
	4: "BINARY",
}
var ValueType_value = map[string]int32{
	"STRING": 0,
	"DOUBLE": 1,
	"BOOL":   2,
	"LONG":   3,
	"BINARY": 4,
}

func (x ValueType) String() string {
	return proto.EnumName(ValueType_name, int32(x))
}
func (ValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{0} }

type SpanRefType int32

const (
	SpanRefType_CHILD_OF     SpanRefType = 0
	SpanRefType_FOLLOWS_FROM SpanRefType = 1
)

var SpanRefType_name = map[int32]string{
	0: "CHILD_OF",
	1: "FOLLOWS_FROM",
}
var SpanRefType_value = map[string]int32{
	"CHILD_OF":     0,
	"FOLLOWS_FROM": 1,
}

func (x SpanRefType) String() string {
	return proto.EnumName(SpanRefType_name, int32(x))
}
func (SpanRefType) EnumDescriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{1} }

type TraceID struct {
	Low  uint64 `protobuf:"varint,1,opt,name=low,proto3" json:"low,omitempty"`
	High uint64 `protobuf:"varint,2,opt,name=high,proto3" json:"high,omitempty"`
}

func (m *TraceID) Reset()                    { *m = TraceID{} }
func (m *TraceID) String() string            { return proto.CompactTextString(m) }
func (*TraceID) ProtoMessage()               {}
func (*TraceID) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{0} }

func (m *TraceID) GetLow() uint64 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *TraceID) GetHigh() uint64 {
	if m != nil {
		return m.High
	}
	return 0
}

type KeyValue struct {
	Key     string    `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	VType   ValueType `protobuf:"varint,2,opt,name=vType,proto3,enum=jaeger.ValueType" json:"vType,omitempty"`
	VStr    string    `protobuf:"bytes,3,opt,name=vStr,proto3" json:"vStr,omitempty"`
	VDouble float64   `protobuf:"fixed64,4,opt,name=vDouble,proto3" json:"vDouble,omitempty"`
	VBool   bool      `protobuf:"varint,5,opt,name=vBool,proto3" json:"vBool,omitempty"`
	VLong   int64     `protobuf:"varint,6,opt,name=vLong,proto3" json:"vLong,omitempty"`
	VBinary []byte    `protobuf:"bytes,7,opt,name=vBinary,proto3" json:"vBinary,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{1} }

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetVType() ValueType {
	if m != nil {
		return m.VType
	}
	return ValueType_STRING
}

func (m *KeyValue) GetVStr() string {
	if m != nil {
		return m.VStr
	}
	return ""
}

func (m *KeyValue) GetVDouble() float64 {
	if m != nil {
		return m.VDouble
	}
	return 0
}

func (m *KeyValue) GetVBool() bool {
	if m != nil {
		return m.VBool
	}
	return false
}

func (m *KeyValue) GetVLong() int64 {
	if m != nil {
		return m.VLong
	}
	return 0
}

func (m *KeyValue) GetVBinary() []byte {
	if m != nil {
		return m.VBinary
	}
	return nil
}

type Log struct {
	Timestamp time.Time  `protobuf:"bytes,1,opt,name=timestamp,stdtime" json:"timestamp"`
	Fields    []KeyValue `protobuf:"bytes,2,rep,name=fields" json:"fields"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{2} }

func (m *Log) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *Log) GetFields() []KeyValue {
	if m != nil {
		return m.Fields
	}
	return nil
}

type SpanRef struct {
	TraceID TraceID     `protobuf:"bytes,1,opt,name=traceID" json:"traceID"`
	SpanID  SpanID      `protobuf:"varint,2,opt,name=spanID,proto3,customtype=SpanID" json:"spanID"`
	RefType SpanRefType `protobuf:"varint,3,opt,name=refType,proto3,enum=jaeger.SpanRefType" json:"refType,omitempty"`
}

func (m *SpanRef) Reset()                    { *m = SpanRef{} }
func (m *SpanRef) String() string            { return proto.CompactTextString(m) }
func (*SpanRef) ProtoMessage()               {}
func (*SpanRef) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{3} }

func (m *SpanRef) GetTraceID() TraceID {
	if m != nil {
		return m.TraceID
	}
	return TraceID{}
}

func (m *SpanRef) GetRefType() SpanRefType {
	if m != nil {
		return m.RefType
	}
	return SpanRefType_CHILD_OF
}

type Process struct {
	ServiceName string     `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	Tags        []KeyValue `protobuf:"bytes,2,rep,name=tags" json:"tags"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{4} }

func (m *Process) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Process) GetTags() []KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Span struct {
	TraceID       TraceID       `protobuf:"bytes,1,opt,name=traceID" json:"traceID"`
	SpanID        SpanID        `protobuf:"varint,2,opt,name=spanID,proto3,customtype=SpanID" json:"spanID"`
	OperationName string        `protobuf:"bytes,3,opt,name=operation_name,json=operationName,proto3" json:"operation_name,omitempty"`
	References    []SpanRef     `protobuf:"bytes,4,rep,name=references" json:"references"`
	Flags         Flags         `protobuf:"varint,5,opt,name=flags,proto3,customtype=Flags" json:"flags"`
	StartTime     time.Time     `protobuf:"bytes,6,opt,name=startTime,stdtime" json:"startTime"`
	Duration      time.Duration `protobuf:"bytes,7,opt,name=duration,stdduration" json:"duration"`
	Tags          []KeyValue    `protobuf:"bytes,8,rep,name=tags" json:"tags"`
	Logs          []Log         `protobuf:"bytes,9,rep,name=logs" json:"logs"`
	Process       *Process      `protobuf:"bytes,10,opt,name=process" json:"process,omitempty"`
	ProcessID     string        `protobuf:"bytes,11,opt,name=processID,proto3" json:"processID,omitempty"`
	Warnings      []string      `protobuf:"bytes,12,rep,name=warnings" json:"warnings,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{5} }

func (m *Span) GetTraceID() TraceID {
	if m != nil {
		return m.TraceID
	}
	return TraceID{}
}

func (m *Span) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

func (m *Span) GetReferences() []SpanRef {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *Span) GetStartTime() time.Time {
	if m != nil {
		return m.StartTime
	}
	return time.Time{}
}

func (m *Span) GetDuration() time.Duration {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Span) GetTags() []KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Span) GetLogs() []Log {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *Span) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

func (m *Span) GetProcessID() string {
	if m != nil {
		return m.ProcessID
	}
	return ""
}

func (m *Span) GetWarnings() []string {
	if m != nil {
		return m.Warnings
	}
	return nil
}

type Trace struct {
	Spans      []*Span            `protobuf:"bytes,1,rep,name=spans" json:"spans,omitempty"`
	ProcessMap map[string]Process `protobuf:"bytes,2,rep,name=processMap" json:"processMap" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Trace) Reset()                    { *m = Trace{} }
func (m *Trace) String() string            { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()               {}
func (*Trace) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{6} }

func (m *Trace) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *Trace) GetProcessMap() map[string]Process {
	if m != nil {
		return m.ProcessMap
	}
	return nil
}

type Batch struct {
	Spans   []*Span `protobuf:"bytes,1,rep,name=spans" json:"spans,omitempty"`
	Process Process `protobuf:"bytes,2,opt,name=process" json:"process"`
}

func (m *Batch) Reset()                    { *m = Batch{} }
func (m *Batch) String() string            { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()               {}
func (*Batch) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{7} }

func (m *Batch) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *Batch) GetProcess() Process {
	if m != nil {
		return m.Process
	}
	return Process{}
}

type GetTraceID struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetTraceID) Reset()                    { *m = GetTraceID{} }
func (m *GetTraceID) String() string            { return proto.CompactTextString(m) }
func (*GetTraceID) ProtoMessage()               {}
func (*GetTraceID) Descriptor() ([]byte, []int) { return fileDescriptorJaeger, []int{8} }

func (m *GetTraceID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterType((*TraceID)(nil), "jaeger.TraceID")
	golang_proto.RegisterType((*TraceID)(nil), "jaeger.TraceID")
	proto.RegisterType((*KeyValue)(nil), "jaeger.KeyValue")
	golang_proto.RegisterType((*KeyValue)(nil), "jaeger.KeyValue")
	proto.RegisterType((*Log)(nil), "jaeger.Log")
	golang_proto.RegisterType((*Log)(nil), "jaeger.Log")
	proto.RegisterType((*SpanRef)(nil), "jaeger.SpanRef")
	golang_proto.RegisterType((*SpanRef)(nil), "jaeger.SpanRef")
	proto.RegisterType((*Process)(nil), "jaeger.Process")
	golang_proto.RegisterType((*Process)(nil), "jaeger.Process")
	proto.RegisterType((*Span)(nil), "jaeger.Span")
	golang_proto.RegisterType((*Span)(nil), "jaeger.Span")
	proto.RegisterType((*Trace)(nil), "jaeger.Trace")
	golang_proto.RegisterType((*Trace)(nil), "jaeger.Trace")
	proto.RegisterType((*Batch)(nil), "jaeger.Batch")
	golang_proto.RegisterType((*Batch)(nil), "jaeger.Batch")
	proto.RegisterType((*GetTraceID)(nil), "jaeger.GetTraceID")
	golang_proto.RegisterType((*GetTraceID)(nil), "jaeger.GetTraceID")
	proto.RegisterEnum("jaeger.ValueType", ValueType_name, ValueType_value)
	golang_proto.RegisterEnum("jaeger.ValueType", ValueType_name, ValueType_value)
	proto.RegisterEnum("jaeger.SpanRefType", SpanRefType_name, SpanRefType_value)
	golang_proto.RegisterEnum("jaeger.SpanRefType", SpanRefType_name, SpanRefType_value)
}
func (this *KeyValue) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*KeyValue)
	if !ok {
		that2, ok := that.(KeyValue)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Key != that1.Key {
		if this.Key < that1.Key {
			return -1
		}
		return 1
	}
	if this.VType != that1.VType {
		if this.VType < that1.VType {
			return -1
		}
		return 1
	}
	if this.VStr != that1.VStr {
		if this.VStr < that1.VStr {
			return -1
		}
		return 1
	}
	if this.VDouble != that1.VDouble {
		if this.VDouble < that1.VDouble {
			return -1
		}
		return 1
	}
	if this.VBool != that1.VBool {
		if !this.VBool {
			return -1
		}
		return 1
	}
	if this.VLong != that1.VLong {
		if this.VLong < that1.VLong {
			return -1
		}
		return 1
	}
	if c := bytes.Compare(this.VBinary, that1.VBinary); c != 0 {
		return c
	}
	return 0
}
func (this *KeyValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyValue)
	if !ok {
		that2, ok := that.(KeyValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.VType != that1.VType {
		return false
	}
	if this.VStr != that1.VStr {
		return false
	}
	if this.VDouble != that1.VDouble {
		return false
	}
	if this.VBool != that1.VBool {
		return false
	}
	if this.VLong != that1.VLong {
		return false
	}
	if !bytes.Equal(this.VBinary, that1.VBinary) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CollectorServiceV1 service

type CollectorServiceV1Client interface {
	PostSpans(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type collectorServiceV1Client struct {
	cc *grpc.ClientConn
}

func NewCollectorServiceV1Client(cc *grpc.ClientConn) CollectorServiceV1Client {
	return &collectorServiceV1Client{cc}
}

func (c *collectorServiceV1Client) PostSpans(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/jaeger.CollectorServiceV1/PostSpans", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CollectorServiceV1 service

type CollectorServiceV1Server interface {
	PostSpans(context.Context, *Batch) (*google_protobuf.Empty, error)
}

func RegisterCollectorServiceV1Server(s *grpc.Server, srv CollectorServiceV1Server) {
	s.RegisterService(&_CollectorServiceV1_serviceDesc, srv)
}

func _CollectorServiceV1_PostSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Batch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectorServiceV1Server).PostSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.CollectorServiceV1/PostSpans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectorServiceV1Server).PostSpans(ctx, req.(*Batch))
	}
	return interceptor(ctx, in, info, handler)
}

var _CollectorServiceV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jaeger.CollectorServiceV1",
	HandlerType: (*CollectorServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostSpans",
			Handler:    _CollectorServiceV1_PostSpans_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "jaeger.proto",
}

// Client API for QueryServiceV1 service

type QueryServiceV1Client interface {
	GetTrace(ctx context.Context, in *GetTraceID, opts ...grpc.CallOption) (*Trace, error)
}

type queryServiceV1Client struct {
	cc *grpc.ClientConn
}

func NewQueryServiceV1Client(cc *grpc.ClientConn) QueryServiceV1Client {
	return &queryServiceV1Client{cc}
}

func (c *queryServiceV1Client) GetTrace(ctx context.Context, in *GetTraceID, opts ...grpc.CallOption) (*Trace, error) {
	out := new(Trace)
	err := grpc.Invoke(ctx, "/jaeger.QueryServiceV1/GetTrace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QueryServiceV1 service

type QueryServiceV1Server interface {
	GetTrace(context.Context, *GetTraceID) (*Trace, error)
}

func RegisterQueryServiceV1Server(s *grpc.Server, srv QueryServiceV1Server) {
	s.RegisterService(&_QueryServiceV1_serviceDesc, srv)
}

func _QueryServiceV1_GetTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTraceID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceV1Server).GetTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.QueryServiceV1/GetTrace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceV1Server).GetTrace(ctx, req.(*GetTraceID))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryServiceV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jaeger.QueryServiceV1",
	HandlerType: (*QueryServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTrace",
			Handler:    _QueryServiceV1_GetTrace_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "jaeger.proto",
}

func (m *TraceID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Low != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.Low))
	}
	if m.High != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.High))
	}
	return i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.VType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.VType))
	}
	if len(m.VStr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(len(m.VStr)))
		i += copy(dAtA[i:], m.VStr)
	}
	if m.VDouble != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.VDouble))))
		i += 8
	}
	if m.VBool {
		dAtA[i] = 0x28
		i++
		if m.VBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VLong != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.VLong))
	}
	if len(m.VBinary) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(len(m.VBinary)))
		i += copy(dAtA[i:], m.VBinary)
	}
	return i, nil
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJaeger(dAtA, i, uint64(types.SizeOfStdTime(m.Timestamp)))
	n1, err := types.StdTimeMarshalTo(m.Timestamp, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Fields) > 0 {
		for _, msg := range m.Fields {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SpanRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJaeger(dAtA, i, uint64(m.TraceID.Size()))
	n2, err := m.TraceID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.SpanID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.SpanID))
	}
	if m.RefType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.RefType))
	}
	return i, nil
}

func (m *Process) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Process) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJaeger(dAtA, i, uint64(m.TraceID.Size()))
	n3, err := m.TraceID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.SpanID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.SpanID))
	}
	if len(m.OperationName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(len(m.OperationName)))
		i += copy(dAtA[i:], m.OperationName)
	}
	if len(m.References) > 0 {
		for _, msg := range m.References {
			dAtA[i] = 0x22
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Flags != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.Flags))
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintJaeger(dAtA, i, uint64(types.SizeOfStdTime(m.StartTime)))
	n4, err := types.StdTimeMarshalTo(m.StartTime, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x3a
	i++
	i = encodeVarintJaeger(dAtA, i, uint64(types.SizeOfStdDuration(m.Duration)))
	n5, err := types.StdDurationMarshalTo(m.Duration, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x42
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Logs) > 0 {
		for _, msg := range m.Logs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Process != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(m.Process.Size()))
		n6, err := m.Process.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.ProcessID) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(len(m.ProcessID)))
		i += copy(dAtA[i:], m.ProcessID)
	}
	if len(m.Warnings) > 0 {
		for _, s := range m.Warnings {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ProcessMap) > 0 {
		for k, _ := range m.ProcessMap {
			dAtA[i] = 0x12
			i++
			v := m.ProcessMap[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovJaeger(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovJaeger(uint64(len(k))) + msgSize
			i = encodeVarintJaeger(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJaeger(dAtA, i, uint64((&v).Size()))
			n7, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n7
		}
	}
	return i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJaeger(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintJaeger(dAtA, i, uint64(m.Process.Size()))
	n8, err := m.Process.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *GetTraceID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTraceID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJaeger(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func encodeVarintJaeger(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TraceID) Size() (n int) {
	var l int
	_ = l
	if m.Low != 0 {
		n += 1 + sovJaeger(uint64(m.Low))
	}
	if m.High != 0 {
		n += 1 + sovJaeger(uint64(m.High))
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovJaeger(uint64(l))
	}
	if m.VType != 0 {
		n += 1 + sovJaeger(uint64(m.VType))
	}
	l = len(m.VStr)
	if l > 0 {
		n += 1 + l + sovJaeger(uint64(l))
	}
	if m.VDouble != 0 {
		n += 9
	}
	if m.VBool {
		n += 2
	}
	if m.VLong != 0 {
		n += 1 + sovJaeger(uint64(m.VLong))
	}
	l = len(m.VBinary)
	if l > 0 {
		n += 1 + l + sovJaeger(uint64(l))
	}
	return n
}

func (m *Log) Size() (n int) {
	var l int
	_ = l
	l = types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovJaeger(uint64(l))
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	return n
}

func (m *SpanRef) Size() (n int) {
	var l int
	_ = l
	l = m.TraceID.Size()
	n += 1 + l + sovJaeger(uint64(l))
	if m.SpanID != 0 {
		n += 1 + sovJaeger(uint64(m.SpanID))
	}
	if m.RefType != 0 {
		n += 1 + sovJaeger(uint64(m.RefType))
	}
	return n
}

func (m *Process) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovJaeger(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	return n
}

func (m *Span) Size() (n int) {
	var l int
	_ = l
	l = m.TraceID.Size()
	n += 1 + l + sovJaeger(uint64(l))
	if m.SpanID != 0 {
		n += 1 + sovJaeger(uint64(m.SpanID))
	}
	l = len(m.OperationName)
	if l > 0 {
		n += 1 + l + sovJaeger(uint64(l))
	}
	if len(m.References) > 0 {
		for _, e := range m.References {
			l = e.Size()
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	if m.Flags != 0 {
		n += 1 + sovJaeger(uint64(m.Flags))
	}
	l = types.SizeOfStdTime(m.StartTime)
	n += 1 + l + sovJaeger(uint64(l))
	l = types.SizeOfStdDuration(m.Duration)
	n += 1 + l + sovJaeger(uint64(l))
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	if m.Process != nil {
		l = m.Process.Size()
		n += 1 + l + sovJaeger(uint64(l))
	}
	l = len(m.ProcessID)
	if l > 0 {
		n += 1 + l + sovJaeger(uint64(l))
	}
	if len(m.Warnings) > 0 {
		for _, s := range m.Warnings {
			l = len(s)
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	return n
}

func (m *Trace) Size() (n int) {
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	if len(m.ProcessMap) > 0 {
		for k, v := range m.ProcessMap {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovJaeger(uint64(len(k))) + 1 + l + sovJaeger(uint64(l))
			n += mapEntrySize + 1 + sovJaeger(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Batch) Size() (n int) {
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovJaeger(uint64(l))
		}
	}
	l = m.Process.Size()
	n += 1 + l + sovJaeger(uint64(l))
	return n
}

func (m *GetTraceID) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovJaeger(uint64(l))
	}
	return n
}

func sovJaeger(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozJaeger(x uint64) (n int) {
	return sovJaeger(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TraceID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			m.High = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.High |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VType", wireType)
			}
			m.VType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VType |= (ValueType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.VDouble = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VBool = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLong", wireType)
			}
			m.VLong = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VLong |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBinary", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VBinary = append(m.VBinary[:0], dAtA[iNdEx:postIndex]...)
			if m.VBinary == nil {
				m.VBinary = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, KeyValue{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TraceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			m.SpanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanID |= (SpanID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			m.RefType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefType |= (SpanRefType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, KeyValue{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TraceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			m.SpanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanID |= (SpanID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, SpanRef{})
			if err := m.References[len(m.References)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (Flags(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdTimeUnmarshal(&m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdDurationUnmarshal(&m.Duration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, KeyValue{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, Log{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Process == nil {
				m.Process = &Process{}
			}
			if err := m.Process.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warnings = append(m.Warnings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessMap == nil {
				m.ProcessMap = make(map[string]Process)
			}
			var mapkey string
			mapvalue := &Process{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJaeger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJaeger
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJaeger
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJaeger
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJaeger
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJaeger
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Process{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJaeger(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJaeger
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProcessMap[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Process.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTraceID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTraceID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTraceID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJaeger
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJaeger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJaeger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJaeger(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJaeger
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJaeger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthJaeger
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowJaeger
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipJaeger(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthJaeger = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJaeger   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("jaeger.proto", fileDescriptorJaeger) }
func init() { golang_proto.RegisterFile("jaeger.proto", fileDescriptorJaeger) }

var fileDescriptorJaeger = []byte{
	// 1052 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xef, 0x24, 0xce, 0xbf, 0x97, 0xa4, 0x0d, 0xb3, 0x80, 0x4c, 0xb6, 0x34, 0xc1, 0xa8, 0x6c,
	0x28, 0x34, 0xa6, 0x41, 0x2b, 0xa1, 0x72, 0x40, 0x75, 0xd3, 0x96, 0x2c, 0x6e, 0x53, 0x9c, 0xb2,
	0xfc, 0xd1, 0x4a, 0x95, 0x9b, 0x4c, 0x5c, 0x83, 0xe3, 0xb1, 0x6c, 0x27, 0x55, 0x84, 0xb8, 0xec,
	0x27, 0xe0, 0xcf, 0x85, 0x1b, 0xf0, 0x4d, 0x56, 0xe2, 0xb2, 0x47, 0x24, 0x6e, 0x1c, 0x16, 0x54,
	0x38, 0xec, 0xc7, 0x40, 0x33, 0x9e, 0x49, 0xda, 0x6e, 0xa5, 0xee, 0x65, 0x2f, 0xed, 0xbc, 0xf7,
	0x7e, 0xef, 0xcd, 0x7b, 0xef, 0xf7, 0xcb, 0x18, 0x4a, 0x5f, 0xdb, 0xc4, 0x21, 0x61, 0x33, 0x08,
	0x69, 0x4c, 0x71, 0x36, 0xb1, 0xaa, 0xb7, 0x1d, 0x4a, 0x1d, 0x8f, 0xe8, 0xdc, 0x7b, 0x32, 0x1e,
	0xea, 0x64, 0x14, 0xc4, 0xd3, 0x04, 0x54, 0xad, 0x5d, 0x0d, 0xc6, 0xee, 0x88, 0x44, 0xb1, 0x3d,
	0x0a, 0x04, 0x60, 0xe5, 0x2a, 0x60, 0x30, 0x0e, 0xed, 0xd8, 0xa5, 0xbe, 0x88, 0x2f, 0x8b, 0xb8,
	0x1d, 0xb8, 0xba, 0xed, 0xfb, 0x34, 0xe6, 0xc1, 0x48, 0x44, 0xdf, 0xe5, 0xff, 0xfa, 0xeb, 0x0e,
	0xf1, 0xd7, 0xa3, 0x33, 0xdb, 0x71, 0x48, 0xa8, 0xd3, 0x80, 0x23, 0xae, 0x41, 0xaf, 0x3b, 0x6e,
	0x7c, 0x3a, 0x3e, 0x69, 0xf6, 0xe9, 0x48, 0x77, 0xa8, 0x43, 0xe7, 0x97, 0x32, 0x8b, 0x1b, 0xfc,
	0x94, 0xc0, 0x35, 0x1d, 0x72, 0x47, 0xa1, 0xdd, 0x27, 0x9d, 0x36, 0xae, 0x40, 0xda, 0xa3, 0x67,
	0x2a, 0xaa, 0xa3, 0x86, 0x62, 0xb1, 0x23, 0xc6, 0xa0, 0x9c, 0xba, 0xce, 0xa9, 0x9a, 0xe2, 0x2e,
	0x7e, 0xd6, 0x7e, 0x47, 0x90, 0xff, 0x84, 0x4c, 0xef, 0xdb, 0xde, 0x98, 0xb0, 0x94, 0x6f, 0xc8,
	0x94, 0xa7, 0x14, 0x2c, 0x76, 0xc4, 0x77, 0x20, 0x33, 0x39, 0x9a, 0x06, 0x84, 0xe7, 0x2c, 0xb6,
	0x5e, 0x6a, 0x8a, 0x75, 0x72, 0x3c, 0x0b, 0x58, 0x49, 0x9c, 0xd5, 0x9e, 0xf4, 0xe2, 0x50, 0x4d,
	0xf3, 0x5c, 0x7e, 0xc6, 0x2a, 0xe4, 0x26, 0x6d, 0x3a, 0x3e, 0xf1, 0x88, 0xaa, 0xd4, 0x51, 0x03,
	0x59, 0xd2, 0xc4, 0x2f, 0x43, 0x66, 0x62, 0x50, 0xea, 0xa9, 0x99, 0x3a, 0x6a, 0xe4, 0xad, 0xc4,
	0xe0, 0x5e, 0x93, 0xfa, 0x8e, 0x9a, 0xad, 0xa3, 0x46, 0xda, 0x4a, 0x0c, 0x5e, 0xc5, 0x70, 0x7d,
	0x3b, 0x9c, 0xaa, 0xb9, 0x3a, 0x6a, 0x94, 0x2c, 0x69, 0x6e, 0xe6, 0x9f, 0xfe, 0x5a, 0x43, 0x4f,
	0x7f, 0xab, 0x21, 0x6d, 0x0a, 0x69, 0x93, 0x3a, 0xd8, 0x80, 0xc2, 0x8c, 0x2b, 0x3e, 0x45, 0xb1,
	0x55, 0x6d, 0x26, 0x64, 0x34, 0xe5, 0xde, 0x9a, 0x47, 0x12, 0x61, 0xe4, 0x1f, 0x3f, 0xa9, 0x2d,
	0x7c, 0xff, 0x77, 0x0d, 0x59, 0xf3, 0x34, 0xdc, 0x84, 0xec, 0xd0, 0x25, 0xde, 0x20, 0x52, 0x53,
	0xf5, 0x74, 0xa3, 0xd8, 0xaa, 0xc8, 0x91, 0xe5, 0x96, 0x0c, 0x85, 0xa5, 0x59, 0x02, 0xa5, 0xfd,
	0x80, 0x20, 0xd7, 0x0b, 0x6c, 0xdf, 0x22, 0x43, 0xac, 0x43, 0x2e, 0x4e, 0xb6, 0x2f, 0x6e, 0x5f,
	0x92, 0xc9, 0x82, 0x14, 0x91, 0x2b, 0x51, 0xf8, 0x2d, 0xc8, 0x46, 0x81, 0xed, 0x77, 0xda, 0x09,
	0x27, 0xc6, 0x22, 0x0b, 0xff, 0xf5, 0xa4, 0x96, 0xed, 0x71, 0xaf, 0x25, 0xa2, 0x78, 0x1d, 0x72,
	0x21, 0x19, 0x72, 0x22, 0xd2, 0x9c, 0x88, 0x5b, 0xb2, 0xb0, 0xb8, 0x9a, 0x53, 0x21, 0x31, 0xda,
	0x17, 0x90, 0x3b, 0x0c, 0x69, 0x9f, 0x44, 0x11, 0x7e, 0x03, 0x4a, 0x11, 0x09, 0x27, 0x6e, 0x9f,
	0x1c, 0xfb, 0xf6, 0x88, 0x08, 0x6e, 0x8b, 0xc2, 0x77, 0x60, 0x8f, 0x08, 0x5e, 0x03, 0x25, 0xb6,
	0x9d, 0x9b, 0xe6, 0xe5, 0x18, 0xed, 0x17, 0x05, 0x14, 0x76, 0xe5, 0x8b, 0x1b, 0x75, 0x15, 0x16,
	0x69, 0x40, 0x92, 0xdf, 0x53, 0xd2, 0x72, 0x22, 0xa9, 0xf2, 0xcc, 0xcb, 0x9b, 0xbe, 0x0b, 0x10,
	0x92, 0x21, 0x09, 0x89, 0xdf, 0x27, 0x91, 0xaa, 0xf0, 0xd6, 0x97, 0xae, 0x2c, 0x45, 0xb4, 0x70,
	0x01, 0x88, 0xdf, 0x84, 0xcc, 0xd0, 0x63, 0xc3, 0x32, 0xe1, 0x95, 0x8d, 0xb2, 0x68, 0x22, 0xb3,
	0xcb, 0x9c, 0x56, 0x12, 0x63, 0x32, 0x8a, 0x62, 0x3b, 0x8c, 0x99, 0x52, 0xb8, 0x16, 0x9f, 0x5b,
	0x46, 0xb3, 0x34, 0xfc, 0x11, 0xe4, 0xe5, 0xab, 0xc0, 0x65, 0x5b, 0x6c, 0xbd, 0xf6, 0x4c, 0x89,
	0xb6, 0x00, 0x24, 0x15, 0x7e, 0x66, 0x15, 0x66, 0x49, 0x33, 0x56, 0xf2, 0x37, 0xb3, 0x82, 0x57,
	0x41, 0xf1, 0xa8, 0x13, 0xa9, 0x05, 0x8e, 0x2d, 0x4a, 0xac, 0x49, 0x1d, 0x09, 0x63, 0x61, 0xfc,
	0x36, 0xe4, 0x82, 0x44, 0x16, 0x2a, 0x5c, 0xe6, 0x4c, 0xa8, 0xc5, 0x92, 0x71, 0xbc, 0x0c, 0x05,
	0x71, 0xec, 0xb4, 0xd5, 0x22, 0x27, 0x60, 0xee, 0xc0, 0x55, 0xc8, 0x9f, 0xd9, 0xa1, 0xef, 0xfa,
	0x4e, 0xa4, 0x96, 0xea, 0xe9, 0x46, 0xc1, 0x9a, 0xd9, 0xda, 0x23, 0x04, 0x19, 0x2e, 0x01, 0xac,
	0x41, 0x86, 0x71, 0x1a, 0xa9, 0x88, 0xb7, 0x55, 0xba, 0xc4, 0x4e, 0x12, 0xc2, 0xdb, 0x00, 0xa2,
	0xec, 0xbe, 0x1d, 0x08, 0x05, 0xbe, 0x7e, 0x49, 0x49, 0xb2, 0xb7, 0x7d, 0x3b, 0xd8, 0xf1, 0xe3,
	0x70, 0x2a, 0x49, 0x9d, 0xa7, 0x55, 0x0f, 0x60, 0xe9, 0x0a, 0xe8, 0x9a, 0x97, 0x6c, 0x15, 0x32,
	0x13, 0xb6, 0x38, 0x2e, 0xbf, 0x6b, 0x46, 0x4f, 0xa2, 0x9b, 0xa9, 0x0f, 0x90, 0xf6, 0x00, 0x32,
	0x86, 0x1d, 0xf7, 0x4f, 0x9f, 0x6b, 0x02, 0x7d, 0xbe, 0xd4, 0xeb, 0x2b, 0xcb, 0x1f, 0x82, 0x40,
	0x69, 0xcb, 0x00, 0x7b, 0x24, 0x96, 0xaf, 0xf4, 0x22, 0xa4, 0xdc, 0x81, 0xe8, 0x33, 0xe5, 0x0e,
	0xd6, 0xb6, 0xa1, 0x30, 0x7b, 0x5b, 0x31, 0x40, 0xb6, 0x77, 0x64, 0x75, 0x0e, 0xf6, 0x2a, 0x0b,
	0xec, 0xdc, 0xee, 0x7e, 0x66, 0x98, 0x3b, 0x15, 0x84, 0xf3, 0xa0, 0x18, 0xdd, 0xae, 0x59, 0x49,
	0xb1, 0x93, 0xd9, 0x3d, 0xd8, 0xab, 0xa4, 0x59, 0xdc, 0xe8, 0x1c, 0x6c, 0x59, 0x5f, 0x56, 0x94,
	0xb5, 0x75, 0x28, 0x5e, 0x78, 0x17, 0x70, 0x09, 0xf2, 0xdb, 0x1f, 0x77, 0xcc, 0xf6, 0x71, 0x77,
	0xb7, 0xb2, 0x80, 0x2b, 0x50, 0xda, 0xed, 0x9a, 0x66, 0xf7, 0xf3, 0xde, 0xf1, 0xae, 0xd5, 0xdd,
	0xaf, 0xa0, 0xd6, 0x09, 0xe0, 0x6d, 0xea, 0x79, 0xa4, 0x1f, 0xd3, 0xb0, 0x97, 0x3c, 0x0c, 0xf7,
	0x37, 0xb0, 0x09, 0x85, 0x43, 0x1a, 0xc5, 0x3d, 0x3e, 0x65, 0x59, 0x0e, 0xc5, 0x17, 0x53, 0x7d,
	0xf5, 0x19, 0x2d, 0xef, 0xb0, 0x0f, 0xa8, 0xa6, 0x3e, 0xfc, 0xf3, 0xbf, 0x9f, 0x52, 0x58, 0x2b,
	0xf3, 0x6f, 0xdf, 0x64, 0x43, 0xe7, 0x3b, 0xda, 0x44, 0x6b, 0xad, 0x07, 0xb0, 0xf8, 0xe9, 0x98,
	0x84, 0xd3, 0x79, 0xfd, 0x7b, 0x90, 0x97, 0x7b, 0xc0, 0x58, 0x96, 0x9f, 0x6f, 0xa6, 0x5a, 0xbe,
	0x24, 0x03, 0xed, 0x36, 0x2f, 0xfd, 0x0a, 0xbe, 0x25, 0x4b, 0xf3, 0x87, 0x25, 0xd2, 0xbf, 0x75,
	0x07, 0xdf, 0x19, 0x0f, 0xd1, 0x8f, 0x5b, 0x06, 0xce, 0xb4, 0xd2, 0x1b, 0xcd, 0xf7, 0xd6, 0x52,
	0x28, 0x15, 0xde, 0x05, 0xb8, 0xc7, 0xb3, 0xeb, 0x5b, 0x87, 0x1d, 0x7c, 0xe7, 0x34, 0x8e, 0x83,
	0x68, 0x53, 0xd7, 0x2f, 0x7c, 0x4c, 0x93, 0xe2, 0xac, 0x88, 0xeb, 0x3b, 0xc2, 0x7a, 0x7c, 0xbe,
	0x82, 0xfe, 0x38, 0x5f, 0x41, 0xff, 0x9c, 0xaf, 0xa0, 0x47, 0xff, 0xae, 0xa0, 0xaf, 0xde, 0xb9,
	0x21, 0x41, 0x1f, 0xd1, 0x01, 0xf1, 0x3e, 0xe4, 0x7f, 0x4f, 0xb2, 0x7c, 0x19, 0xef, 0xff, 0x1f,
	0x00, 0x00, 0xff, 0xff, 0xf9, 0xee, 0x1f, 0x7d, 0x73, 0x08, 0x00, 0x00,
}
